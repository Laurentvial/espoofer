from common.common import *
import re

class ExploitsBuilder(object):

	def __init__(self, test_cases, config):
		self.config = config
		self.case_id = config['case_id'].decode("utf-8")
		self.mode = config['mode']
		self.test_cases = self.fixup_test_case_data(test_cases)


	def fixup_test_case_data(self, t):
		if self.config['mode'] == 'c':
			t = recursive_fixup(t, b"attacker@example.com", self.config["client_mode"]["username"])
			t = recursive_fixup(t, b"admin@example.com", self.config["legitimate_site_address"])
			t= recursive_fixup(t, b"victim@victim.com", self.config["victim_address"])
		else:
			t = recursive_fixup(t, b"attack.com", self.config["attacker_site"])
			t = recursive_fixup(t, b"admin@legitimate.com", self.config["legitimate_site_address"])
			legitimate_site = self.config["legitimate_site_address"].split(b"@")[1]
			t = recursive_fixup(t, b"legitimate.com", legitimate_site)
			t= recursive_fixup(t, b"victim@victim.com", self.config["victim_address"])

		# Appliquer le subject_header si défini (même vide, on veut pouvoir le remplacer)
		if 'subject_header' in self.config:
			subject = self.config['subject_header']
			# Si le subject_header est vide, ne rien faire (garder celui du test case)
			if subject:
				# Convertir en bytes si nécessaire
				if not isinstance(subject, bytes):
					subject = str(subject).encode('utf-8')
				
				# Décoder pour vérifier le format
				try:
					subject_str = subject.decode('utf-8')
				except:
					subject_str = subject.decode('utf-8', errors='ignore')
				
				subject_stripped = subject_str.strip()
				if subject_stripped:
					# Vérifier si ça commence par "Subject:" (case insensitive)
					if not subject_stripped.lower().startswith('subject:'):
						# Ajouter "Subject: " si manquant
						subject = b"Subject: " + subject_stripped.encode('utf-8')
					else:
						# Enlever "Subject:" du début pour le reformater proprement
						subject_text = subject_stripped
						if subject_text.lower().startswith('subject:'):
							subject_text = subject_text[8:].strip()  # Enlever "Subject:"
						subject = b"Subject: " + subject_text.encode('utf-8')
					
					# S'assurer qu'il se termine par \r\n
					if not subject.endswith(b'\r\n'):
						if subject.endswith(b'\n'):
							subject = subject[:-1] + b'\r\n'
						else:
							subject = subject + b'\r\n'
					
					t[self.case_id]['data']['subject_header'] = subject
		# Appliquer le to_header si défini
		if self.config.get('to_header'):
			to_header = self.config['to_header']
			# Convertir en bytes si nécessaire
			if not isinstance(to_header, bytes):
				to_header = str(to_header).encode('utf-8')
			
			# Décoder pour vérifier le format
			try:
				to_header_str = to_header.decode('utf-8')
			except:
				to_header_str = to_header.decode('utf-8', errors='ignore')
			
			to_header_stripped = to_header_str.strip()
			if to_header_stripped:
				# Vérifier si ça commence par "To:" (case insensitive)
				if not to_header_stripped.lower().startswith('to:'):
					# Ajouter "To: " si manquant
					to_header = b"To: " + to_header_stripped.encode('utf-8')
				else:
					# Enlever "To:" du début pour le reformater proprement
					to_text = to_header_stripped
					if to_text.lower().startswith('to:'):
						to_text = to_text[3:].strip()  # Enlever "To:"
					to_header = b"To: " + to_text.encode('utf-8')
				
				# S'assurer qu'il se termine par \r\n
				if not to_header.endswith(b'\r\n'):
					if to_header.endswith(b'\n'):
						to_header = to_header[:-1] + b'\r\n'
					else:
						to_header = to_header + b'\r\n'
				
				t[self.case_id]['data']['to_header'] = to_header
		if self.config.get('body'):
			t[self.case_id]['data']['body'] =self.config['body']
		
		# Stocker le reply_to pour l'ajouter après le from_header
		reply_to_header = None
		if self.config.get('reply_to'):
			reply_to = self.config['reply_to']
			# Convertir en bytes si nécessaire
			if not isinstance(reply_to, bytes):
				reply_to = str(reply_to).encode('utf-8')
			
			# Décoder pour vérifier le format
			try:
				reply_to_str = reply_to.decode('utf-8')
			except:
				reply_to_str = reply_to.decode('utf-8', errors='ignore')
			
			reply_to_stripped = reply_to_str.strip()
			if reply_to_stripped:
				# Enlever "Reply-To:" du début si présent
				if reply_to_stripped.lower().startswith('reply-to:'):
					reply_to_stripped = reply_to_stripped[9:].strip()
				
				# Formater correctement avec chevrons si nécessaire
				reply_text = reply_to_stripped.strip()
				# Si le texte ne contient pas déjà de chevrons, les ajouter
				if not (reply_text.startswith('<') and reply_text.endswith('>')):
					# Vérifier si c'est juste un email ou "Name <email>"
					if '<' in reply_text and '>' in reply_text:
						# Format déjà correct: "Name <email>"
						reply_text_bytes = reply_text.encode('utf-8')
					else:
						# Juste un email, ajouter les chevrons
						reply_text_bytes = b"<" + reply_text.encode('utf-8') + b">"
				else:
					reply_text_bytes = reply_text.encode('utf-8')
				
				# Construire le header Reply-To
				reply_to_header = b"Reply-To: " + reply_text_bytes + b"\r\n"
		
		# Appliquer le from_email personnalisé si défini (pour le spoofing)
		from_email = None
		if self.config.get('from_email'):
			from_email = self.config['from_email']
		
		# Appliquer le sender_name et/ou from_email si définis
		if self.config.get('sender_name') or from_email:
			sender_name = self.config.get('sender_name', b'')
			from_header = t[self.case_id]['data']['from_header']
			
			# Déterminer l'email à utiliser
			if from_email:
				# Utiliser l'email personnalisé pour le spoofing
				email = from_email
			else:
				# Extraire l'email existant du header From
				from_match = re.search(rb'From:\s*(?:([^<>\r\n]+)\s*)?<([^>]+)>', from_header)
				if from_match:
					email = from_match.group(2)
				else:
					# Essayer le format sans chevrons
					from_match = re.search(rb'From:\s*([^\s\r\n]+@[^\s\r\n]+)', from_header)
					if from_match:
						email = from_match.group(1)
					else:
						email = None
			
			# Construire le nouveau header From
			if email:
				if sender_name:
					# Format: From: Nom <email@domain.com>\r\n
					new_from = b"From: " + sender_name + b" <" + email + b">\r\n"
				else:
					# Format: From: <email@domain.com>\r\n
					new_from = b"From: <" + email + b">\r\n"
				
				# Remplacer le premier From header
				from_header = re.sub(rb'From:\s*[^\r\n]+\r\n', new_from, from_header, count=1)
				t[self.case_id]['data']['from_header'] = from_header
		
		# Ajouter le Reply-To juste après le From header pour une meilleure reconnaissance
		if reply_to_header:
			from_header = t[self.case_id]['data']['from_header']
			# Ajouter le Reply-To après le From header
			t[self.case_id]['data']['from_header'] = from_header + reply_to_header

		return t

	def generate_msg_data(self):
		test_cases = self.test_cases
		case_id = self.case_id
		msg_content = test_cases[case_id]["data"]
		dkim_para = test_cases[case_id].get("dkim_para")
		if dkim_para != None:
			dkim_msg =   dkim_para["sign_header"] +b"\r\n\r\n" + msg_content["body"]
			dkim_header = generate_dkim_header(dkim_msg, dkim_para)
			msg = msg_content["from_header"] + dkim_header + msg_content["to_header"] + msg_content["subject_header"] + msg_content["other_headers"] + msg_content["body"]
		else:
			msg = msg_content["from_header"] + msg_content["to_header"] + msg_content["subject_header"] + msg_content["other_headers"] + msg_content["body"]
		return msg

	def generate_smtp_seqs(self):
		test_cases = self.test_cases
		case_id = self.case_id

		smtp_seqs = {
			"helo": test_cases[case_id]["helo"],
			"mailfrom": test_cases[case_id]["mailfrom"],
			"rcptto": test_cases[case_id]["rcptto"],
			"msg_content": self.generate_msg_data()
		}
		return smtp_seqs
