from common.common import *
import re
import os
import base64
import mimetypes

class ExploitsBuilder(object):

	def __init__(self, test_cases, config):
		self.config = config
		self.case_id = config['case_id'].decode("utf-8")
		self.mode = config['mode']
		self.test_cases = self.fixup_test_case_data(test_cases)


	def fixup_test_case_data(self, t):
		if self.config['mode'] == 'c':
			t = recursive_fixup(t, b"attacker@example.com", self.config["client_mode"]["username"])
			t = recursive_fixup(t, b"admin@example.com", self.config["legitimate_site_address"])
			t= recursive_fixup(t, b"victim@victim.com", self.config["victim_address"])
		else:
			t = recursive_fixup(t, b"attack.com", self.config["attacker_site"])
			t = recursive_fixup(t, b"admin@legitimate.com", self.config["legitimate_site_address"])
			legitimate_site = self.config["legitimate_site_address"].split(b"@")[1]
			t = recursive_fixup(t, b"legitimate.com", legitimate_site)
			t= recursive_fixup(t, b"victim@victim.com", self.config["victim_address"])

		# Appliquer le subject_header si défini (même vide, on veut pouvoir le remplacer)
		if 'subject_header' in self.config:
			subject = self.config['subject_header']
			# Si le subject_header est vide, ne rien faire (garder celui du test case)
			if subject:
				# Convertir en bytes si nécessaire
				if not isinstance(subject, bytes):
					subject = str(subject).encode('utf-8')
				
				# Décoder pour vérifier le format
				try:
					subject_str = subject.decode('utf-8')
				except:
					subject_str = subject.decode('utf-8', errors='ignore')
				
				subject_stripped = subject_str.strip()
				if subject_stripped:
					# Vérifier si ça commence par "Subject:" (case insensitive)
					if not subject_stripped.lower().startswith('subject:'):
						# Ajouter "Subject: " si manquant
						subject = b"Subject: " + subject_stripped.encode('utf-8')
					else:
						# Enlever "Subject:" du début pour le reformater proprement
						subject_text = subject_stripped
						if subject_text.lower().startswith('subject:'):
							subject_text = subject_text[8:].strip()  # Enlever "Subject:"
						subject = b"Subject: " + subject_text.encode('utf-8')
					
					# S'assurer qu'il se termine par \r\n
					if not subject.endswith(b'\r\n'):
						if subject.endswith(b'\n'):
							subject = subject[:-1] + b'\r\n'
						else:
							subject = subject + b'\r\n'
					
					t[self.case_id]['data']['subject_header'] = subject
		# Appliquer le to_header si défini
		if self.config.get('to_header'):
			to_header = self.config['to_header']
			# Convertir en bytes si nécessaire
			if not isinstance(to_header, bytes):
				to_header = str(to_header).encode('utf-8')
			
			# Décoder pour vérifier le format
			try:
				to_header_str = to_header.decode('utf-8')
			except:
				to_header_str = to_header.decode('utf-8', errors='ignore')
			
			to_header_stripped = to_header_str.strip()
			if to_header_stripped:
				# Vérifier si ça commence par "To:" (case insensitive)
				if not to_header_stripped.lower().startswith('to:'):
					# Ajouter "To: " si manquant
					to_header = b"To: " + to_header_stripped.encode('utf-8')
				else:
					# Enlever "To:" du début pour le reformater proprement
					to_text = to_header_stripped
					if to_text.lower().startswith('to:'):
						to_text = to_text[3:].strip()  # Enlever "To:"
					to_header = b"To: " + to_text.encode('utf-8')
				
				# S'assurer qu'il se termine par \r\n
				if not to_header.endswith(b'\r\n'):
					if to_header.endswith(b'\n'):
						to_header = to_header[:-1] + b'\r\n'
					else:
						to_header = to_header + b'\r\n'
				
				t[self.case_id]['data']['to_header'] = to_header
		if self.config.get('body'):
			t[self.case_id]['data']['body'] =self.config['body']
		
		# Stocker le reply_to pour l'ajouter après le from_header
		reply_to_header = None
		if self.config.get('reply_to'):
			reply_to = self.config['reply_to']
			# Convertir en bytes si nécessaire
			if not isinstance(reply_to, bytes):
				reply_to = str(reply_to).encode('utf-8')
			
			# Décoder pour vérifier le format
			try:
				reply_to_str = reply_to.decode('utf-8')
			except:
				reply_to_str = reply_to.decode('utf-8', errors='ignore')
			
			reply_to_stripped = reply_to_str.strip()
			if reply_to_stripped:
				# Enlever "Reply-To:" du début si présent
				if reply_to_stripped.lower().startswith('reply-to:'):
					reply_to_stripped = reply_to_stripped[9:].strip()
				
				# Formater correctement avec chevrons si nécessaire
				reply_text = reply_to_stripped.strip()
				# Si le texte ne contient pas déjà de chevrons, les ajouter
				if not (reply_text.startswith('<') and reply_text.endswith('>')):
					# Vérifier si c'est juste un email ou "Name <email>"
					if '<' in reply_text and '>' in reply_text:
						# Format déjà correct: "Name <email>"
						reply_text_bytes = reply_text.encode('utf-8')
					else:
						# Juste un email, ajouter les chevrons
						reply_text_bytes = b"<" + reply_text.encode('utf-8') + b">"
				else:
					reply_text_bytes = reply_text.encode('utf-8')
				
				# Construire le header Reply-To
				reply_to_header = b"Reply-To: " + reply_text_bytes + b"\r\n"
		
		# Appliquer le from_email personnalisé si défini (pour le spoofing)
		from_email = None
		if self.config.get('from_email'):
			from_email = self.config['from_email']
		
		# Appliquer le sender_name et/ou from_email si définis
		if self.config.get('sender_name') or from_email:
			sender_name = self.config.get('sender_name', b'')
			from_header = t[self.case_id]['data']['from_header']
			
			# Déterminer l'email à utiliser
			if from_email:
				# Utiliser l'email personnalisé pour le spoofing
				email = from_email
			else:
				# Extraire l'email existant du header From
				from_match = re.search(rb'From:\s*(?:([^<>\r\n]+)\s*)?<([^>]+)>', from_header)
				if from_match:
					email = from_match.group(2)
				else:
					# Essayer le format sans chevrons
					from_match = re.search(rb'From:\s*([^\s\r\n]+@[^\s\r\n]+)', from_header)
					if from_match:
						email = from_match.group(1)
					else:
						email = None
			
			# Construire le nouveau header From
			if email:
				if sender_name:
					# Format: From: Nom <email@domain.com>\r\n
					new_from = b"From: " + sender_name + b" <" + email + b">\r\n"
				else:
					# Format: From: <email@domain.com>\r\n
					new_from = b"From: <" + email + b">\r\n"
				
				# Remplacer le premier From header
				from_header = re.sub(rb'From:\s*[^\r\n]+\r\n', new_from, from_header, count=1)
				t[self.case_id]['data']['from_header'] = from_header
		
		# Ajouter le Reply-To juste après le From header pour une meilleure reconnaissance
		if reply_to_header:
			from_header = t[self.case_id]['data']['from_header']
			# Ajouter le Reply-To après le From header
			t[self.case_id]['data']['from_header'] = from_header + reply_to_header

		return t

	def generate_msg_data(self):
		test_cases = self.test_cases
		case_id = self.case_id
		msg_content = test_cases[case_id]["data"]
		dkim_para = test_cases[case_id].get("dkim_para")
		
		# Vérifier s'il y a des pièces jointes
		attachments = self.config.get("attachments", [])
		
		if attachments:
			# Créer un message multipart/mixed avec pièces jointes
			boundary = self._generate_boundary()
			headers = msg_content["from_header"] + msg_content["to_header"] + msg_content["subject_header"]
			
			# Ajouter les headers MIME
			mime_headers = b"Content-Type: multipart/mixed; boundary=\"" + boundary.encode("utf-8") + b"\"\r\n"
			mime_headers += b"MIME-Version: 1.0\r\n"
			
			# Ajouter DKIM si nécessaire
			if dkim_para != None:
				dkim_msg = dkim_para["sign_header"] + b"\r\n\r\n" + msg_content["body"]
				dkim_header = generate_dkim_header(dkim_msg, dkim_para)
				headers = msg_content["from_header"] + dkim_header + msg_content["to_header"] + msg_content["subject_header"]
			
			# Construire le message multipart
			msg = headers + mime_headers + msg_content["other_headers"]
			
			# Partie 1: Corps du message
			msg += b"\r\n--" + boundary.encode("utf-8") + b"\r\n"
			msg += b"Content-Type: text/plain; charset=\"UTF-8\"\r\n"
			msg += b"Content-Transfer-Encoding: 8bit\r\n"
			msg += b"\r\n"
			msg += msg_content["body"]
			
			# Partie 2: Pièces jointes
			for attachment_path in attachments:
				if os.path.exists(attachment_path):
					attachment_data = self._encode_attachment(attachment_path)
					if attachment_data:
						msg += b"\r\n--" + boundary.encode("utf-8") + b"\r\n"
						msg += attachment_data
			
			# Fin du message multipart
			msg += b"\r\n--" + boundary.encode("utf-8") + b"--\r\n"
		else:
			# Message simple sans pièces jointes
			if dkim_para != None:
				dkim_msg = dkim_para["sign_header"] + b"\r\n\r\n" + msg_content["body"]
				dkim_header = generate_dkim_header(dkim_msg, dkim_para)
				msg = msg_content["from_header"] + dkim_header + msg_content["to_header"] + msg_content["subject_header"] + msg_content["other_headers"] + msg_content["body"]
			else:
				msg = msg_content["from_header"] + msg_content["to_header"] + msg_content["subject_header"] + msg_content["other_headers"] + msg_content["body"]
		
		return msg
	
	def _generate_boundary(self):
		"""Génère une boundary unique pour le message multipart"""
		import random
		import string
		chars = string.ascii_letters + string.digits
		boundary = "----=_NextPart_" + ''.join(random.choice(chars) for _ in range(20))
		return boundary
	
	def _encode_attachment(self, file_path):
		"""Encode un fichier en base64 pour l'attacher au message"""
		try:
			import os
			filename = os.path.basename(file_path)
			
			# Détecter le type MIME
			mime_type, _ = mimetypes.guess_type(file_path)
			if not mime_type:
				mime_type = "application/octet-stream"
			
			# Lire le fichier en mode binaire
			with open(file_path, 'rb') as f:
				file_data = f.read()
			
			# Encoder en base64
			encoded_data = base64.b64encode(file_data)
			
			# Construire la partie MIME
			attachment_part = b"Content-Type: " + mime_type.encode("utf-8") + b"; name=\"" + filename.encode("utf-8") + b"\"\r\n"
			attachment_part += b"Content-Disposition: attachment; filename=\"" + filename.encode("utf-8") + b"\"\r\n"
			attachment_part += b"Content-Transfer-Encoding: base64\r\n"
			attachment_part += b"\r\n"
			
			# Ajouter les données encodées (par lignes de 76 caractères max)
			chunk_size = 76
			for i in range(0, len(encoded_data), chunk_size):
				attachment_part += encoded_data[i:i+chunk_size] + b"\r\n"
			
			return attachment_part
		except Exception as e:
			print(f"Erreur lors de l'encodage de la pièce jointe {file_path}: {e}")
			return None

	def generate_smtp_seqs(self):
		test_cases = self.test_cases
		case_id = self.case_id

		smtp_seqs = {
			"helo": test_cases[case_id]["helo"],
			"mailfrom": test_cases[case_id]["mailfrom"],
			"rcptto": test_cases[case_id]["rcptto"],
			"msg_content": self.generate_msg_data()
		}
		return smtp_seqs
